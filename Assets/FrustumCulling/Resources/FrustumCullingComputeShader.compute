#pragma kernel CSMain
#define FRUSTUM_PLANE_COUNT 6
#define THREAD_GROUP_X 256
#define THREAD_GROUP_Y 1
#define THREAD_GROUP_Z 1

struct BufferData
{
    float3 center;
    float3 extents;
};

StructuredBuffer<BufferData> boundsBuffer;
RWStructuredBuffer<uint> resultBuffer;
float4x4 _LastVp;
float4 frustumPlanes[FRUSTUM_PLANE_COUNT];
uint _Count;


float FrustumPlaneTest(BufferData bufferData)
{
	float3 center = bufferData.center;
    float3 extents = bufferData.extents;
    float3 boundsMin = center - extents;
    float3 boundsMax = center + extents;

	[unroll]
    for(uint i = 0; i < FRUSTUM_PLANE_COUNT; i++)
    {
        float3 normal = frustumPlanes[i].xyz;
        float planeDistance = frustumPlanes[i].w;
        float3 bounds = lerp(boundsMin, boundsMax, step(0, normal));
        
        if(dot(normal, bounds) + planeDistance < 0.5)
        {
            return 0;
        }
    }
    
    return 1;
}

static const float3 aggressiveExtentArray[8] =
{
    float3(1, 1, 1),
    float3(1, 1, -1),
    float3(1, -1, 1),
    float3(1, -1, -1),
    float3(-1, 1, 1),
    float3(-1, 1, -1),
    float3(-1, -1, 1),
    float3(-1, -1, -1)
};
float4 _HizScreenRes;
Texture2D<half> _HizDepthTex;
SamplerState sampler_HizDepthTex;
float OcclusionTest(BufferData bufferData, float4x4 vpMat)
{
    #ifdef UNITY_REVERSED_Z
    float minZ = 0;
    #else
    float minZ = 1;
    #endif
    float2 maxXY = 0; float2 minXY = 1;
    for(uint i = 0; i < 8; ++i)
    {
       float3 boxCorner = bufferData.center + bufferData.extents * aggressiveExtentArray[i]; 
       float4 clipPos = mul(vpMat, float4(boxCorner, 1));
       clipPos /= clipPos.w;
       minXY = min(clipPos.xy, minXY);
       maxXY = max(clipPos.xy, maxXY);
       #ifdef UNITY_REVERSED_Z
       minZ = max(minZ, clipPos.z);
       #else
       minZ = min(minZ, clipPos.z);
       #endif
    }
    float4 boxUVs = float4(minXY, maxXY);
    boxUVs = saturate(boxUVs * 0.5 + 0.5);
    float2 size = (boxUVs.zw - boxUVs.xy) * _HizScreenRes.xy;
    float mip = (log2(max(size.x, size.y)));
    if(mip > _HizScreenRes.z)
    {
        return 1;
    }
    mip = ceil(mip);
    mip = min(mip, _HizScreenRes.w);
	float level_lower = max(mip - 1, 0);
	float2 scale = exp2(-level_lower) * _HizScreenRes.xy;
	float2 a = floor(boxUVs.xy * scale);
	float2 b = ceil(boxUVs.zw * scale);
	float2 dims = b - a;
	
	// Use the lower level if we only touch <= 2 texels in both dimensions
	if (dims.x <= 2 && dims.y <= 2)
	mip = level_lower;

    float4 depth = float4(_HizDepthTex.SampleLevel(sampler_HizDepthTex, boxUVs.xy, mip),
                         _HizDepthTex.SampleLevel(sampler_HizDepthTex, boxUVs.zy, mip),
                         _HizDepthTex.SampleLevel(sampler_HizDepthTex, boxUVs.xw, mip),
                         _HizDepthTex.SampleLevel(sampler_HizDepthTex, boxUVs.zw, mip)
    );

    #ifdef UNITY_REVERSED_Z
    depth.xy = min(depth.xy, depth.zw);
    depth.x = min(depth.x, depth.y);
    return minZ >= depth.x;
    #else
    depth.xy = max(depth.xy, depth.zw);
    depth.x = max(depth.x, depth.y);
    return minZ <= depth.x;
    #endif
}

[numthreads(THREAD_GROUP_X, THREAD_GROUP_Y, THREAD_GROUP_Z)]
void CSMain (uint id : SV_DispatchThreadID)
{
	if(id >= _Count)
	{
		return;
	}

    resultBuffer[id] = FrustumPlaneTest(boundsBuffer[id]);

	/*
	if(resultBuffer[id] > 0.5)
	{
		resultBuffer[id] = OcclusionTest(boundsBuffer[id], _LastVp);
	}
	*/
}
